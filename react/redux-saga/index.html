<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>redux-saga 浅析 | 个人主页</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/img/logo.ico">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/img/logo.png">
    <meta name="description" content="常敏杰的博客">
    
    <link rel="preload" href="/assets/css/0.styles.f014b934.css" as="style"><link rel="preload" href="/assets/js/app.73ed0f99.js" as="script"><link rel="preload" href="/assets/js/2.67e34e85.js" as="script"><link rel="preload" href="/assets/js/8.29780db4.js" as="script"><link rel="prefetch" href="/assets/js/10.7f540330.js"><link rel="prefetch" href="/assets/js/11.02b60cbf.js"><link rel="prefetch" href="/assets/js/12.12376c9d.js"><link rel="prefetch" href="/assets/js/13.8892aae1.js"><link rel="prefetch" href="/assets/js/14.bbcc7304.js"><link rel="prefetch" href="/assets/js/15.aed58648.js"><link rel="prefetch" href="/assets/js/16.f8080887.js"><link rel="prefetch" href="/assets/js/17.b85e52dc.js"><link rel="prefetch" href="/assets/js/18.ee3504f2.js"><link rel="prefetch" href="/assets/js/19.42c4c61a.js"><link rel="prefetch" href="/assets/js/20.b76090ce.js"><link rel="prefetch" href="/assets/js/21.2eaa853b.js"><link rel="prefetch" href="/assets/js/22.3ff69789.js"><link rel="prefetch" href="/assets/js/23.fd2c35ab.js"><link rel="prefetch" href="/assets/js/24.65c5cce5.js"><link rel="prefetch" href="/assets/js/25.96813b95.js"><link rel="prefetch" href="/assets/js/26.e3322333.js"><link rel="prefetch" href="/assets/js/27.dba65289.js"><link rel="prefetch" href="/assets/js/28.4262c73c.js"><link rel="prefetch" href="/assets/js/29.6a92b436.js"><link rel="prefetch" href="/assets/js/3.d4905b5f.js"><link rel="prefetch" href="/assets/js/30.66e120d6.js"><link rel="prefetch" href="/assets/js/31.08523322.js"><link rel="prefetch" href="/assets/js/32.e28fc3d1.js"><link rel="prefetch" href="/assets/js/33.93b3a069.js"><link rel="prefetch" href="/assets/js/34.86413756.js"><link rel="prefetch" href="/assets/js/35.cea74fba.js"><link rel="prefetch" href="/assets/js/36.1f1fbb43.js"><link rel="prefetch" href="/assets/js/37.568ca527.js"><link rel="prefetch" href="/assets/js/38.36291238.js"><link rel="prefetch" href="/assets/js/39.6655a304.js"><link rel="prefetch" href="/assets/js/4.43d31d04.js"><link rel="prefetch" href="/assets/js/40.2f25a167.js"><link rel="prefetch" href="/assets/js/41.ca70beeb.js"><link rel="prefetch" href="/assets/js/42.f59133d6.js"><link rel="prefetch" href="/assets/js/43.0c28e9a9.js"><link rel="prefetch" href="/assets/js/44.aa936aaf.js"><link rel="prefetch" href="/assets/js/45.fcb5b21b.js"><link rel="prefetch" href="/assets/js/46.844ece96.js"><link rel="prefetch" href="/assets/js/47.436b41d4.js"><link rel="prefetch" href="/assets/js/48.19700ec8.js"><link rel="prefetch" href="/assets/js/49.75302b25.js"><link rel="prefetch" href="/assets/js/5.53eb6ffc.js"><link rel="prefetch" href="/assets/js/50.adb79790.js"><link rel="prefetch" href="/assets/js/51.d22dc8d7.js"><link rel="prefetch" href="/assets/js/52.816b9e71.js"><link rel="prefetch" href="/assets/js/53.8b5e1175.js"><link rel="prefetch" href="/assets/js/54.7a6d801b.js"><link rel="prefetch" href="/assets/js/6.27411842.js"><link rel="prefetch" href="/assets/js/7.72925e1b.js"><link rel="prefetch" href="/assets/js/9.994f1183.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f014b934.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">个人主页</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/recent/" class="nav-link">
  最新文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react/" class="nav-link router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.zhihu.com/people/jay-55-9/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MinjieChang/myblog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/recent/" class="nav-link">
  最新文章
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/react/" class="nav-link router-link-active">
  react
</a></li><li class="dropdown-item"><!----> <a href="/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/css/" class="nav-link">
  css
</a></li></ul></div></div><div class="nav-item"><a href="/node/" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://www.zhihu.com/people/jay-55-9/posts" target="_blank" rel="noopener noreferrer" class="nav-link external">
  知乎
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/MinjieChang/myblog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">目录</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>designPattern</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>react</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/optimization/" class="sidebar-link">react 性能优化</a></li><li><a href="/react/ssr/" class="sidebar-link">react ssr 构建</a></li><li><a href="/react/redux-saga/" aria-current="page" class="active sidebar-link">redux-saga 浅析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/redux-saga/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#saga概念" class="sidebar-link">saga概念</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#effect" class="sidebar-link">effect</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/redux-saga/#take" class="sidebar-link">take</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#模拟take实现" class="sidebar-link">模拟take实现</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#takeevery实现" class="sidebar-link">takeEvery实现</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#effect的本质" class="sidebar-link">effect的本质</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#fork与call" class="sidebar-link">fork与call</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#cancle" class="sidebar-link">cancle</a></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#put" class="sidebar-link">put</a></li></ul></li><li class="sidebar-sub-header"><a href="/react/redux-saga/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/react/breadcrumb/" class="sidebar-link">react 实现动态面包屑导航</a></li><li><a href="/react/roadhog/" class="sidebar-link">dora + atool-build 升级到 roadhog</a></li><li><a href="/react/redux/" class="sidebar-link">redux 实现</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>helpers</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="redux-saga-浅析"><a href="#redux-saga-浅析" class="header-anchor">#</a> redux-saga 浅析</h1> <p>本文目录</p> <ul><li><a href="#redux-saga-%E6%B5%85%E6%9E%90">redux-saga 浅析</a> <ul><li><a href="#%E5%89%8D%E8%A8%80">前言</a></li> <li><a href="#saga%E6%A6%82%E5%BF%B5">saga概念</a></li> <li><a href="#effect">effect</a> <ul><li><a href="#take">take</a></li> <li><a href="#%E6%A8%A1%E6%8B%9Ftake%E5%AE%9E%E7%8E%B0">模拟take实现</a></li> <li><a href="#takeevery%E5%AE%9E%E7%8E%B0">takeEvery实现</a></li> <li><a href="#effect%E7%9A%84%E6%9C%AC%E8%B4%A8">effect的本质</a></li> <li><a href="#fork%E4%B8%8Ecall">fork与call</a></li> <li><a href="#cancle">cancle</a></li> <li><a href="#put">put</a></li></ul></li> <li><a href="#%E6%80%BB%E7%BB%93">总结</a></li></ul></li></ul> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>redux提供了一套中间件的方式用以对action的处理，我们常用的中间件一般有<a href="https://github.com/reduxjs/redux-thunk" target="_blank" rel="noopener noreferrer">redux-thunk<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>(下文以thunk代指)，这个库我们比较熟悉了，主要用于对函数类型的action的处理。除了redux-thunk，常用的中间件还有redux-saga(下文以saga代指)，redux-saga提供了很丰富的api，让我们比较容易的处理一些异步操作。saga的使用可以参考<a href="https://redux-saga-in-chinese.js.org/" target="_blank" rel="noopener noreferrer">saga的自述<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，在本篇文章中，我们主要探究saga的实现方式。</p> <h2 id="saga概念"><a href="#saga概念" class="header-anchor">#</a> saga概念</h2> <p>saga这一概念来源于后端事物，一个事物通常会包含多个子事物，这几个子事物组合在一起，就称作一个saga。比如用户购买火车票这个事物，它包含了用户订票、付款、退票、出票这几个动作。</p> <p>在redux-saga中，一个generator函数定义为一个saga函数，在此generator函数中会包含对一个异步事务的完整处理流程。</p> <h2 id="effect"><a href="#effect" class="header-anchor">#</a> effect</h2> <p>effect在saga中是个很常见的概念，任务的发起都是通过effect来实现，在下文的叙述中会对这个概念有进一步的认识</p> <h3 id="take"><a href="#take" class="header-anchor">#</a> take</h3> <p>让我们先从saga提供的一个简单的api开始吧。take是saga提供的一个监听acton的api，它的基本用法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> sagaMiddleware<span class="token punctuation">,</span> take <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;redux-saga&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token string">'action_name'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'监听到了action'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

sagaMiddleware<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>mainSaga<span class="token punctuation">)</span>
</code></pre></div><p>一个基本的结构还是很简单的，从这个示例中，我们可以发现几个特点：</p> <ul><li>saga函数使用generator表示，这也是它处理异步任务的方式</li> <li>在saga函数中，take会监听action，直到监听到了预期的action_name，才会继续向下执行，否则会一直阻塞着</li> <li>初始条件下，需要执行<code>sagaMiddleware.run(mainSaga)</code>，执行的作用，大致可以猜想一下，可能是进行某种注册操作，否则take如何来监听呢？</li></ul> <p>总结一下，saga在初始情况下会进行注册操作，然后在saga函数中使用take进行监听。这个流程似乎有点发布订阅的模式的身影，那我们就顺着这个思路来模拟实现一下take函数</p> <h3 id="模拟take实现"><a href="#模拟take实现" class="header-anchor">#</a> 模拟take实现</h3> <p>这里我们主要是模拟实现sagaMiddleware.run和take这两个函数。实现之前我们先了解下两个概念：</p> <ul><li>task：task在saga中表示generator函数的执行环境</li> <li>effect：effect在saga中是比较重要的概念，saga中提供的诸多方法可以称为effect，这里的take就是一种effect类型</li></ul> <p>先实现一个task：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">let</span> resule <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>resule<span class="token punctuation">,</span> <span class="token string">'get_start'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token string">'take'</span><span class="token punctuation">,</span>
    actionName<span class="token operator">:</span> name<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">runTakeEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 交出next的执行权，由用户决定什么时候再执行</span>
  <span class="token comment">// 所以此时需要把 next存储起来，供用户触发</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">const</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> effect <span class="token operator">=</span> result<span class="token punctuation">.</span>value
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'take'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">runTakeEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">task</span><span class="token punctuation">(</span>mainSaga<span class="token punctuation">)</span>
</code></pre></div><p>下面分析一下task函数的执行过程：</p> <ul><li>把mainSaga作为参数传入到task函数中，执行mainSaga函数得到一个迭代器g，</li> <li>然后在task中定义了一next函数，这个next函数中执行g.next方法，执行g.next()实际上是执行到了 yield take()这里，并且g.next()会返回一个结果result</li> <li>result包含done和result两个属性，然后首先判断done属性，如果done属性为false，表明迭代器还未执行完毕；再判断value属性的值，注意，value属性的值是执行take返回的值。take函数实际就是一个返回纯对象的函数，这个对象包含一个type属性，表明这个task的类别</li> <li>判断effect的type值，如果type的值是take，就执行runTakeEffect函数，并且把effect和next作为参数传入</li></ul> <p>接下来的主要工作是实现runTakeEffect，这个函数的作用主要有两个：</p> <ul><li>转让迭代器的控制权，也就是需要把迭代器使用变量保存起来</li> <li>等待用户触发了特定的事件后再执行迭代器</li></ul> <p>由于这里需要对迭代器做存储，所以这里还需要引入saga中的另外一个概念：</p> <ul><li>channel：channel主要用于做事件的存储和触发，这一点和发布订阅模式中事件调度中心很类似</li></ul> <p>runTakeEffect的实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">channle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">let</span> taker <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token keyword">function</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    taker <span class="token operator">=</span> cb
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>taker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 每一个take函数被触发后都将被销毁，</span>
      <span class="token keyword">let</span> tempTaker <span class="token operator">=</span> taker
      taker <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token function">tempTaker</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    take<span class="token punctuation">,</span>
    put
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> chan <span class="token operator">=</span> <span class="token function">channle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">runTakeEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 交出next的执行权，由用户决定什么时候再执行</span>
  <span class="token comment">// 所以此时需要把 next存储起来，供用户触发</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> type<span class="token punctuation">,</span> actionName <span class="token punctuation">}</span> <span class="token operator">=</span> effect
  <span class="token comment">// 这里的action是用户出发的aciton的名称</span>
  chan<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
    <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">===</span> actionName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">next</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解析一下runTakeEffect的逻辑：</p> <ul><li>channel提供了两个函数，一个是take，用来存储监听的回调函数；一个是put，用来触发监听事件的回调函数，需要注意的是，take的put函数在执行完毕回调函数后会立即将其销毁。所以take的监听有效性只有一次，被触发后就不会再监听了。</li> <li>在runTakeEffect会触发channel的take，存储一个函数，此函数中会对用户触发的action和监听的aciton进行对比，如果一致才会出发next函数，进入gen迭代器的下一个迭代环节，并且把effect作为参数传入，作为take的返回值</li></ul> <p>现在一个大体的take函数基本实现完毕了，我们来模拟用户的操作事件来测试一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span>
</code></pre></div><p>执行结果如下：</p> <p><img src="/assets/img/1.dc75c1c3.png" alt="1.png"></p> <p>我们触发了两次<code>chan.put</code>， 但实际上监听函数只执行了一次，这是由于在第一次执行完后就被销毁了。</p> <h3 id="takeevery实现"><a href="#takeevery实现" class="header-anchor">#</a> takeEvery实现</h3> <p>saga提供了一个takeEvery的api，作为对take的补充，不同于take监听的一次性有效，它对于action的监听是始终有效的，它的基本使用方法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">takeEvery</span><span class="token punctuation">(</span><span class="token string">'action_name'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do something</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以看到，takeEvery有两个参数，第一个参数是监听的action，第二个参数是监听的执行函数</p> <p>实际上，在实现takeEvery之前，我们可以使用一个无限循环的take来模拟下takeEvery，达到无限监听的目的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token string">'get_start'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>原理很简单，就是使用一个死循环来实现，当上一个taker执行完并被销毁后，此时会再次进入下次迭代循环：</p> <div class="language-js extra-class"><pre class="language-js"><code>chan<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">action</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
  <span class="token keyword">if</span> <span class="token punctuation">(</span>action <span class="token operator">===</span> actionName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">next</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>再次执行next，又到<code>yield take('start')</code>这句，再次想chan中添加监听方法，重复之前的过程，达到持续监听的目的。</p> <p>了解了takeEvery要做到的事情，接下来就模拟实现一下。在这之前，还需要再了解一下saga提供的另外一个api：</p> <ul><li>fork：fork的作用是启动一个新的task，不阻塞原有的task。这有别于take，take是阻塞执行的。同样，fork也是一种effect类型，因此很容易就能想到，它返回的也是一个纯对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token string">'fork'</span><span class="token punctuation">,</span>
    fn<span class="token operator">:</span> cb
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">takeEvery</span><span class="token punctuation">(</span><span class="token parameter">action<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// fork 的目的是重启一个task，是不是和我们上面的模拟实现takeEvery很类似</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token operator">*</span><span class="token punctuation">(</span>params<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span>
      <span class="token function">cb</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token function">takeEvery</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">effect</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> <span class="token string">'takeEvery_start'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">task</span><span class="token punctuation">(</span>mainSaga<span class="token punctuation">)</span>
</code></pre></div><p>接下来就是要重点实现task的部分：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runForkEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 此时effect可能是个iterator也可能是个纯对象</span>
  <span class="token comment">// 初次启动 task(mainSaga2)，会返回一个iterator，所以此时的effect是个iterator</span>
  <span class="token comment">// 如果effect是个iterator，那么就重启一个task，把iterator放入task中执行一遍</span>
  <span class="token comment">// 重启的task和之前的task互不影响，</span>
  <span class="token function">task</span><span class="token punctuation">(</span>effect<span class="token punctuation">.</span>fn <span class="token operator">||</span> effect<span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 需要判断gen是否为函数</span>
  <span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span>  <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> gen
  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token keyword">const</span> effect <span class="token operator">=</span> result<span class="token punctuation">.</span>value
    <span class="token comment">// 判断当前的effect是否是个iterator，如果是iterator，那么会放入到runForkEffect中重启一个task</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>effect <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> effect<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
      <span class="token function">runForkEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// console.log(effect.type, 'effect.type')</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'take'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runTakeEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'fork'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runForkEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
        <span class="token comment">// todo</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>修改后的task还是比较绕的，我们来分析一下它的执行过程：</p> <ul><li>首次执行<code>task(mainSaga)</code>，进入task函数，此时mainSaga类型为函数，然后执行mainSaga()，此时返回一个迭代器g，然后再执行next，在next中执行<code>g.next(args)，这里就比较关键了，此时来到</code>yield takeEvery()<code>，由于takeEvery也是个genarator函数，所以takeEvery会返回一个iterator，意味着</code>const effect = result.value<code>中的effect是个iterator，符合这句条件判断</code>effect &amp;&amp; typeof effect[Symbol.iterator] === 'function'<code>，函数进入到</code>runForkEffect`</li> <li>来到runForkEffect，执行<code>task(effect.fn || effect)</code>，由于effect是个iterator，其effect.fn为undefined，这句相当于<code>task(effect)</code>，于是再次来到了task函数</li> <li>这次task的参数gen是个迭代器，所以g就是gen，然后再次执行next来到<code>const result = g.next(args)</code>，注意，此时是<strong>takeEvery返回的迭代器执行了next</strong>，所以此时就来到了<code>yield fork()</code>这句，此时<code>const effect = result.value</code>语句返回的effect就是fork函数返回的纯对象了<code>{type: 'fork', fn: cb}</code>，然后顺其自然的，函数执行到<code>runForkEffect(effect, next)</code></li> <li>再次来到了runForkEffect，此时的参数effect就是一个对象了，会把effect的fn属性作为参数传人task，再次开启一个任务，此时的fn就是fork方法中的参数</li> <li>然后再次来到了task，一路执行函数最终会来到runTakeEffect这句，剩下的事情就是执行runTakeEffect，其执行过程和我们之前的分析一致了。</li></ul> <p>最后，加入如下测试方法，会发现每次执行chan.put都实现了监听：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'start'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1500</span><span class="token punctuation">)</span>
</code></pre></div><p>至此，就实现了takeEvery方法，现在小总结一下：</p> <ul><li>takeEvery借助了一个fork方法，fork的作用在于开启一个新的task。实际上，也可以在takeEvery函数中不用fork，直接使用while循环也可，但是在这个例子中通过进一步的抽象提取出了fork这个方法，所以这个思想还是很值得学习的。</li> <li>重新改进了一下task方法，兼容了参数是iterator和generator的两种情况，这个方法比较难理解的点在于初始化的时候调用runForkEffect的情况。</li></ul> <h3 id="effect的本质"><a href="#effect的本质" class="header-anchor">#</a> effect的本质</h3> <p>到此，对effect有一些认识了，这里对effect总结一下，先看一下官方的解释：</p> <blockquote><p>An effect is a plain JavaScript Object containing some instructions to be executed by the saga middleware.</p></blockquote> <p>意思是，effect是个纯对象，包含一些指令信息，这些指令会被middleware解释执行。</p> <p>通过上面的两个例子，我们已经认识到了两个effect，一个是take，一个是frok，他们实际上都是一个对象，相当于给执行器task发送指令，task通过判断effect的不同类型知道要处理什么样的任务。这就是task的本质。</p> <p>所以基于这种通过effect给task发送指令的做法，我们再来模拟实现如call、cancle等api，实际上，saga中提供的effects中的api也是这么做的。</p> <h3 id="fork与call"><a href="#fork与call" class="header-anchor">#</a> fork与call</h3> <p>在上面实现takeEvery的过程中，我们实现了一个辅助函数fork，fork的作用是启动一个新的task实现无阻塞调用。与之相对的是另外一个effect叫call，call的作用的也是调用有副作用的函数，它是阻塞调用的。它的基本用法如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 首先定义一个异步方法</span>
<span class="token keyword">function</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token parameter">time <span class="token operator">=</span> <span class="token number">1000</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello saga'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> time<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 使用call调用</span>
<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">sagaByCall</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'call_end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里会等待2秒，才打印出call_end</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如上所述，调用<code>yield call</code>后，函数将被阻塞住，2秒过后才会继续向下执行到<code>console</code>语句</p> <p>它的实现也是比较简单的，我们需要判断一下，call调用的函数返回的结果，如果是promise，就等其结果resolve后再继续执行迭代器的next方法，如果不是promise，就直接调用next方法继续迭代器的执行。</p> <p>首先实现一下call，和fork类似，它也是返回描述effect的纯对象的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token string">'call'</span><span class="token punctuation">,</span>
    <span class="token function-variable function">fn</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后再改造一下task函数，需要变动的地方就是在判断effect的类型的条件中增加一项：</p> <div class="language-js extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'take'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runTakeEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'fork'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">runForkEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'call'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 这里增加一项effct的type属性是call的判断</span>
        <span class="token function">runCallEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后再实现runCallEffect函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runCallEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> effect<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 如果result类型是promise，调用resolvePromise，就是等待promise状态置为resolve后再执行迭代器的next方法</span>
  <span class="token comment">// 从而实现阻塞的效果</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPromise</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token function">resolvePromise</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>
  <span class="token function">next</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">isPromise</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> result <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> result<span class="token punctuation">.</span>then <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>next<span class="token punctuation">,</span> <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token function">next</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到此，一个基本的call方法就完成了。</p> <p>需要提醒的是，此处我们使用了call直接调用了delay方法 <code>call(delay)</code>，这是没有问题的，但是我们自己在上文中实现的fork却不能直接这么调用，这是由于fork是重启了一个task，而task的参数我们设定的只能是iterator和generator函数，因此fork的参数不能是一个基本的函数，所以在我们的fork版本中，需要这么来调用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 使用call调用</span>
<span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">sagaByFork</span><span class="token punctuation">(</span><span class="token parameter">params</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token function">sleep</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fork_end'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里我们传递给fork的是一个generator函数，在此方法中再调用delay方法。</p> <p>实际上，在saga的使用中，我们传给fork的函数不必是一个generator函数，可以是一个普通的函数，这是由于saga在runForkEffect函数中做了兼容处理，它会判断函数参数的返回值是否为一个iterator，如果不是则转化为一个iterator，这里我们为了方便描述，未做此兼容。saga做的兼容代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runForkEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> effect<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>is<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> result
  <span class="token punctuation">}</span>
  <span class="token comment">// 否则模拟出一个迭代器</span>
  <span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> iterator
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> resolved <span class="token operator">=</span> <span class="token boolean">false</span>
  <span class="token keyword">const</span> <span class="token function-variable function">next</span> <span class="token operator">=</span> <span class="token parameter">arg</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>resolved<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      resolved <span class="token operator">=</span> <span class="token boolean">true</span>
      <span class="token comment">// Only promises returned from fork will be interpreted. See #1573</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> result<span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token operator">!</span>is<span class="token punctuation">.</span><span class="token function">promise</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> arg<span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 这里的throw 和 return省略掉</span>
  <span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token punctuation">{</span> next<span class="token operator">:</span> next<span class="token punctuation">,</span> <span class="token keyword">throw</span><span class="token operator">:</span> <span class="token string">''</span><span class="token punctuation">,</span> <span class="token keyword">return</span><span class="token operator">:</span> <span class="token string">''</span> <span class="token punctuation">}</span>
  iterator<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> iterator
  <span class="token keyword">return</span> iterator
<span class="token punctuation">}</span>
</code></pre></div><p>以上是对call和fork的使用简单的对比，并且基本能了解到阻塞与非阻塞调用的实现的原理。</p> <p>在使用场景上，fork的非阻塞特性更适用于后台不影响主流程的代码(比如后台打点/开启监听等)，这往往是加快页面渲染的一种方式。而call更适用于需要立即获取结果的异步调用，将异步的回调转为同步的写法，这就和<code>async、await</code>很类似了，关于<code>generator与async、await的联系</code>可以参考我之前的这篇<a href="../../js/async">文章</a>。</p> <h3 id="cancle"><a href="#cancle" class="header-anchor">#</a> cancle</h3> <p>saga还提供了一个很有的用的effect类型即cancel，它可以取消正在运行中的task，saga在取消task后还做了两个工作，一个是取消saga中还未完成的逻辑，另一个是可以执行<a href="https://redux-saga-in-chinese.js.org/docs/advanced/NonBlockingCalls.html" target="_blank" rel="noopener noreferrer">清理操作<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，以保持前后状态的一致性，比如异步操作中的loading状态。</p> <p>先看一下它是如何使用的吧：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">authorize</span><span class="token punctuation">(</span><span class="token parameter">user<span class="token punctuation">,</span> password</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理登陆成功的逻辑</span>
    <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>Api<span class="token punctuation">.</span>authorize<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span>
    <span class="token keyword">yield</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">'LOGIN_SUCCESS'</span><span class="token punctuation">,</span> token<span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> token
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理登陆失败的逻辑</span>
    <span class="token keyword">yield</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">{</span>type<span class="token operator">:</span> <span class="token string">'LOGIN_ERROR'</span><span class="token punctuation">,</span> error<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// 处理请求被取消的逻辑</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token function">cancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// ... put special cancellation handling code here</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">loginFlow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span>authorize<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span>
  <span class="token keyword">const</span> action <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'LOGOUT'</span><span class="token punctuation">,</span> <span class="token string">'LOGIN_ERROR'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>action<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'LOGOUT'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token function">cancel</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">yield</span> <span class="token function">call</span><span class="token punctuation">(</span>Api<span class="token punctuation">.</span><span class="token function">clearItem</span><span class="token punctuation">(</span><span class="token string">'token'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这是官网提供的一个例子，在这个saga中实现的功能是，fork一个登陆的方法authorize，同时监听用户的剩余操作，正常情况下，登陆流程走完会执行try中的语句，如果登陆出现异常会执行catch语句，这两个流程属于正常流程。</p> <p>如果在登陆的过程中，用户发起了取消操作，saga检测到发起的action的type是LOGOUT，此时就取消掉fork发起的task，authorize进入到finally语句，并通过<code>yield cancelled()</code>判断是否是取消操作，此时再做取消操作的特殊处理</p> <p>取消任务的操作实际上使用的场景并不是很多，主要是给用户撤销或是反悔的操作，弥补用户的误操作。下面简析一下实现原理</p> <p>如官网所述，<strong>若要取消正在运行的任务，middleware 将调用底层 Generator 对象上的 return。这将取消任务中的当前 Effect，并跳转至 finally 区块（若有定义的话）</strong>。</p> <p>先设定一下我们要达到的目的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">mainSaga</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> forkTask <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token function">sleep</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'sleep_done'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'resolved'</span><span class="token punctuation">)</span>
  <span class="token keyword">yield</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token string">'cancle'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cancle_taked'</span><span class="token punctuation">)</span>
  <span class="token comment">// 取消task</span>
  <span class="token keyword">yield</span> <span class="token function">cancle</span><span class="token punctuation">(</span>forkTask<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cancle_end'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">task</span><span class="token punctuation">(</span>mainSaga<span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'cancle'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>在这个例子中，先使用fork来发起一个task，在这个task中2秒后会打印出sleep_done，然后监听了用户发起的action，如果action是cancle，就执行cancle取消掉task，最终打印出cancle_end。</p> <p>然后在调用中，我们在1秒后发起了cancel的action，此时由于fork的task还未完成，所以将被取消掉，task中的consle语句将不被执行到。</p> <p>接下来的任务就是修改task方法和创建一个cancel方法。首先cancle仍然是effect类型：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">cancle</span><span class="token punctuation">(</span><span class="token parameter">taskId</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    type<span class="token operator">:</span> <span class="token string">'cancle'</span><span class="token punctuation">,</span>
    taskId<span class="token operator">:</span> taskId
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后再改造task方法，主要是增加了两个地方：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">task</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> gen
  <span class="token comment">// 判断 gen 是函数类型，保存对迭代器对象的引用</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> gen <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    gen<span class="token punctuation">.</span>g <span class="token operator">=</span> g
  <span class="token punctuation">}</span>
  <span class="token comment">//....</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>effect<span class="token punctuation">.</span>type <span class="token operator">===</span> <span class="token string">'cancle'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> <span class="token string">'cancle-effect'</span><span class="token punctuation">)</span>
      <span class="token function">runCancleEffect</span><span class="token punctuation">(</span>effect<span class="token punctuation">,</span> next<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再添加runCancleEffect方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">runCancleEffect</span><span class="token punctuation">(</span><span class="token parameter">effect<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> taskId<span class="token operator">:</span> <span class="token punctuation">{</span> fn<span class="token operator">:</span> <span class="token punctuation">{</span> g <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> effect
  g<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在runCancleEffect中的操作很简单，就是执行了迭代器的return方法，终止迭代器的向下执行。</p> <p>测试后，执行的结果符合我们的预期。
<img src="/assets/img/2.77641bc9.png" alt="3"></p> <p>现在修改下测试例子，在3秒后再执行<code>chan.put('cancel')</code>:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> 
  chan<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'cancle'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
</code></pre></div><p>期望的结果是，由于此时fork的task已经执行完毕，所以cancel并不能起到效果。sleep_done会被正常打印出来。
<img src="/assets/img/3.865bd8e9.png" alt="3"></p> <h3 id="put"><a href="#put" class="header-anchor">#</a> put</h3> <p>put的作用就是纯粹的发起一个acton到store中，功能和dispatch一致。我们已经得出了实现一个effect的一般方法了，这里对于put的实现就不再展开了。当然实现put需要和redux联系起来，毕竟还需要引用其dispatch。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>通过上面的实践，我们大致能了解到saga的工作原理，实现的还比较的粗浅，很多场景也未考虑到，本文的主要目的是对于saga的工作原理有个认识。saga中还提供了很多强大的功能及对异常的捕获处理，这里未涉及到。</p> <p>完整代码访问<a href="https://github.com/MinjieChang/simple-redux-saga" target="_blank" rel="noopener noreferrer">地址<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>refer：</p> <p><a href="https://zhuanlan.zhihu.com/p/30098155" target="_blank" rel="noopener noreferrer">浅析redux-saga实现<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://zhuanlan.zhihu.com/p/23012870" target="_blank" rel="noopener noreferrer">redux-saga实践总结<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br> <a href="https://www.yuque.com/shinima/blog/qtarrq" target="_blank" rel="noopener noreferrer">构建你自己的 redux-saga<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><br></p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">11/3/2020, 5:39:24 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/react/ssr/" class="prev">
        react ssr 构建
      </a></span> <span class="next"><a href="/react/breadcrumb/">
        react 实现动态面包屑导航
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.73ed0f99.js" defer></script><script src="/assets/js/2.67e34e85.js" defer></script><script src="/assets/js/8.29780db4.js" defer></script>
  </body>
</html>
